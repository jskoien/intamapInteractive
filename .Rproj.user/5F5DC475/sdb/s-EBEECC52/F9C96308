{
    "collab_server" : "",
    "contents" : "\nestimateParameters.automap = function(object,...) {\n\n  dots = list(...)\n  if (\"debug.level\" %in% names(dots)) \n  \tdebug.level = dots$debug.level \n  else \n    debug.level = object$params$debug.level\n  observations = object$observations\n  depVar = as.character(object$formulaString[[2]])\n  if (\"model\" %in% names(dots)) {\n    model = dots$model\n  } else if (\"model\" %in% names(object$params)) {\n    model = object$params$model\n  } else {\n    if (dim(coordinates(object$predictionLocations))[1] > 100000) \n            model = c(\"Sph\", \"Exp\", \"Gau\") else model = c(\"Sph\", \"Exp\", \"Gau\", \"Ste\")\n  }\n    \n#estimate Anisotropy\n  if (object$params$doAnisotropy) {\n    object = estimateAnisotropy(object) \n    if (object$anisPar$doRotation && all(as.character(object$formulaString[[3]])==\"1\")){\n\t\t\t#rotate Data\n\t\t\t\tobjTemp = object\n        objTemp$observations=rotateAnisotropicData(objTemp$observations,objTemp$anisPar)\n\t\t\t\t#Estimate Variogram Model\n #       if (\"model\" %in% names(dots)) {\n #   \t\t\t afv = autofitVariogram(objTemp$formulaString, objTemp$observations,\n #                  verbose = (debug.level >=2), ...)\n #       } else {\n\t\t\t    afv = autofitVariogram(objTemp$formulaString, objTemp$observations,\n                   verbose = (debug.level >=2), model = model, ...)\n#\t\t\t  }\n        vario = afv$var_model\t\t\t\t\n\t\t\t\tovar = var(observations[,depVar]@data)\n      \tif ((vario$model[2]  == \"Gau\" | (vario$model[2] == \"Ste\" && vario$kappa[2] > 2)) \n            && vario$psill[1] <= ovar/1e5 ) vario$psill[1] = ovar/1e5   \n        #Combine the isotropic Model with anisotropy parameters\n\t\t\t\tvario$anis1[2]=1/objTemp$anisPar$ratio\n\t\t\t\tvario$ang1[2]=90-objTemp$anisPar$direction\n        if (vario$ang1[2] < 0) vario$ang1[2] = vario$ang1[2] + 180\t\t\t\t\n\t\t\t\tobject$variogramModel=vario\n#\t\t\t\tvario$range=vario$range/objTemp$anisPar$ratio\n  \t} else {\n\t\tafv = autofitVariogram(object$formulaString,observations,verbose=(debug.level >=2),...)\n    \tobject$variogramModel = afv$var_model\n    }\n  } else { \n  \tafv = autofitVariogram(object$formulaString,observations,verbose=(debug.level >=2),...)\n  \tobject$variogramModel = afv$var_model\n  }\n  if (debug.level >=2) print(object$variogramModel)\n  object$sampleVariogram = afv$exp_var\n  return(object)\n}\n\nspatialPredict.automap = function(object, nsim = 0, ...) {\n# This function does not take the clusters properly into account at the moment. \n# Variograms should be estimated separately, prediction locations needs to \n# be associated with a cluster and we need to figure out what to do in the case \n# of \n# \n  params = getIntamapParams(object$params, ...)\n  nmax = params$nmax\n  debug.level = params$debug.level\n  maxdist = params$maxdist\n  if (is.null(maxdist)) maxdist = Inf\n  \n    if (! \"variogramModel\" %in% names(object)) object = estimateParameters(object,...)\n    \n    nPred = nrow(coordinates(object$predictionLocations))\n    if (\"nclus\" %in% names(params) && nsim == 0 && nPred >= 5000 ) \n      nclus = params$nclus else nclus = 1\n    if (nclus > 1) {\n      if (!suppressMessages(suppressWarnings(requireNamespace(\"doParallel\"))))\n  \t    stop(\"nclus is > 1, but package doParallel is not available\")    \n\n    #  clus <- c(rep(\"localhost\", nclus))\n      cl <- makeCluster(nclus)\n      registerDoParallel(cl, nclus)\n#      clusterEvalQ(cl, library(gstat))\n#      clusterEvalQ(cl, gstat::krige)\n      formulaString = object$formulaString\n      observations = object$observations\n      predictionLocations = object$predictionLocations\n      variogramModel = object$variogramModel\n#      clusterExport(cl, list(\"formulaString\", \"observations\", \"predictionLocations\",\n#           \"variogramModel\", \"nmax\", \"nsim\", \"debug.level\"))\n     # split prediction locations:\n      splt = sample(1:nclus, nPred, replace = TRUE)\n      splt = rep(1:nclus, each = ceiling(nPred/nclus), length.out = nPred)\n      newdlst = lapply(as.list(1:nclus), function(w) predictionLocations[splt == w,])\n      i = 1 # To avoid R CMD check complain about missing i\n      pred <- foreach(i = 1:nclus, .combine = rbind) %dopar% {\n        gstat::krige(formulaString, observations, \n           newdlst[[i]], variogramModel, nsim=nsim, nmax = nmax, maxdist = maxdist, debug.level = debug.level)\n      }\n#      pred = do.call(\"rbind\", parLapply(cl, newdlst, function(lst) \n#          krige(formulaString,observations, \n#           predictionLocations,variogramModel,nsim=nsim,nmax = nmax,debug.level = debug.level)))\n      stopCluster(cl)\n    } else {  \n      pred = krige(object$formulaString, object$observations, \n           object$predictionLocations, object$variogramModel, nsim=nsim, nmax = nmax,\n           maxdist = maxdist, debug.level = debug.level)\n      if (nsim >0) {\n        pred2 = krige(object$formulaString,object$observations, \n           object$predictionLocations, object$variogramModel, nmax = nmax, maxdist = maxdist, \n           debug.level = debug.level)\n        pred@data = cbind(pred2@data, pred@data)\n      }\n    }\n    object$predictions = pred\n    if (\"MOK\" %in% names(object$outputWhat) | \"IWQSEL\" %in% names(object$outputWhat))\n      object$predictions = unbiasedKrige(object, debug.level = debug.level,...)$predictions\n  object\n}\n\n\nestimateParameters.yamamoto = function(object,...) {\n  estimateParameters.automap(object,...)\n}\n\n\n\n\nspatialPredict.yamamoto = function(object, nsim = 0, ...) {\n# \n  dots = list(...)\n  if (\"nmax\" %in% names(dots)) {\n    nmax = dots$nmax\n  } else nmax = object$params$nmax\n  if (\"maxdist\" %in% names(dots)) {\n    maxdist = dots$maxdist\n  } else maxdist = object$params$maxdist\n  if (is.null(maxdist)) maxdist = Inf\n  formulaString = object$formulaString\n  if (\"debug.level\" %in% names(dots)) debug.level = dots$debug.level else \n    debug.level = object$params$debug.level\n\n  if (!\"variogramModel\" %in% names(object)) {\n    afv = autofitVariogram(object$formulaString,object$observations,object$predictionLocations)\n  \tobject$variogramModel = afv$var_model\n\tobject$sampleVariogram = afv$exp_var\n  }\n                     \n  predictions = yamamotoKrige(formulaString,object$observations, \n            object$predictionLocations,object$variogramModel, nsim=nsim, nmax = nmax, maxdist = maxdist, ...)\n  object$predictions = predictions\n    if (\"MOK\" %in% names(object$outputWhat) | \"IWQSEL\" %in% names(object$outputWhat))\n      object$predictions = unbiasedKrige(object,debug.level = debug.level,nsim = nsim, nmax = nmax, \n                                         maxdist = maxdist, ...)$predictions\n  object\n}\n\n",
    "created" : 1475157558850.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1492887227",
    "id" : "F9C96308",
    "lastKnownWriteTime" : 1475250195,
    "last_content_update" : 1475250195856,
    "path" : "E:/Intamap/SVNI/intamap/R/pointKriging.R",
    "project_path" : "R/pointKriging.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}