{
    "collab_server" : "",
    "contents" : "\n\nestimateParameters.transGaussian = function(object, ...) {\n  params = getIntamapParams(object$params, ...)\n  lambda = object$params$lambda\n  significant = object$params$significant = TRUE\n  observations = object$observations\n  formulaString = object$formulaString\n  dataObs = observations[[as.character(formulaString[[2]]) ]]\n  if (is.null(lambda)) {\n    test = isNonGauss(dataObs)\n#    if (min(dataObs <=0)) {\n#      pcor = sqrt(var(dataObs))/10000\n#      if (min(dataObs) + pcor > 0 & length(dataObs <= 0) < length(dataObs)/4) {\n#        dataObs = dataObs+pcor\n#        object$TGcorrection = pcor\n#      } \n#    }\n    if (test || !significant)  lambda = bcFit(dataObs) else lambda = 1\n#    if (lambda == 1 && !is.null(object$TGcorrection)) {\n#       object$TGcorrection = 0\n#       dataObs = observations[[as.character(formulaString[[2]]) ]]\n#    } \n  }\n  dataObsBC = bcTrans(dataObs,lambda)\n  object$observations[[as.character(formulaString[[2]]) ]] = dataObsBC\n  object$lambda = lambda\n  object = estimateParameters.automap(object,...)\n  object$observations = observations\n  object\n}\n\n\nspatialPredict.transGaussian = function(object, nsim = 0, ...) {\n  dots = list(...)\n  params = getIntamapParams(object$params, ...)\n  nmax = params$nmax\n  maxdist = params$maxdist\n  if (is.null(maxdist)) maxdist = Inf\n  debug.level = params$debug.level\n  nclus = params$nclus\n  if (! \"variogramModel\" %in% names(object)) object = estimateParameters(object,...)\n  if (\"lambda\" %in% names(object)) {\n    lambda = object$lambda \n  } else if (\"lambda\" %in% names(dots)) {\n    lambda = dots$lambda\n  } else lambda = 1\n  observations = object$observations\n  formulaString = object$formulaString\n  predictionLocations = object$predictionLocations\n#    if (!is.null(object$TGcorrection)) \n#      observations[[as.character(formulaString[[2]])]] = \n#             observations[[as.character(formulaString[[2]])]]+ object$TGcorrection\n\n  nPred = nrow(coordinates(object$predictionLocations))\n  if (\"nclus\" %in% names(object$params) && nsim == 0 && nPred >= 5000 ) \n    nclus = params$nclus else nclus = 1\n  if (nclus > 1) {\n    if (!suppressMessages(suppressWarnings(requireNamespace(\"doParallel\"))))\n  \t    stop(\"nclus is > 1, but package doParallel is not available\")    \n\n    cl <- makeCluster(nclus)\n      registerDoParallel(cl, nclus)\n#      clusterEvalQ(cl, gstat::krigeTg)\n      variogramModel = object$variogramModel\n      splt = rep(1:nclus, each = ceiling(nPred/nclus), length.out = nPred)\n      newPredLoc = lapply(as.list(1:nclus), function(w) predictionLocations[splt == w,])\n      i = 1 # To avoid R CMD check complain about missing i\n      pred <- foreach(i = 1:nclus, .combine = rbind) %dopar% {\n        gstat::krigeTg(formulaString, observations,\n           newPredLoc[[i]], variogramModel, nmax = nmax, maxdist = maxdist, \n           debug.level = debug.level, lambda = lambda)\n      }\n      pred = pred[c(\"var1TG.pred\",\"var1TG.var\")]\n      names(pred) = c(\"var1.pred\",\"var1.var\")\n      stopCluster(cl)\n    } else {  \n      pred = krigeTg(formulaString, observations,\n           object$predictionLocations, object$variogramModel, nmax = nmax,\n           debug.level = debug.level, lambda = lambda)\n      pred = pred[c(\"var1TG.pred\",\"var1TG.var\")]\n      names(pred) = c(\"var1.pred\",\"var1.var\")\n      if (nsim >0) {\n        pred2 = krigeTg(formulaString, observations,\n           object$predictionLocations, object$variogramModel, nmax = nmax, maxdist = maxdist,\n           debug.level = debug.level, nsim = nsim, lambda = lambda)\n        pred@data = cbind(pred@data, pred2@data)\n      }\n    }\n\n\n\n#    if (!is.null(object$TGcorrection)) pred$var1.pred = pred$var1.pred - object$TGcorrection\n    object$predictions = pred\n    if (\"MOK\" %in% names(object$outputWhat) | \"IWQSEL\" %in% names(object$outputWhat))\n      object$predictions = unbiasedKrige(object, debug.level = debug.level, ...)$predictions\n  object\n}\n\n\n\n\nbcFit = function(z, lambda = seq(-3,3,1/100), eps = 1/50) {\n\tbc = boxcox(z~1, lambda = lambda, plotit = FALSE)\n\tm = length(bc$x)\n\tlambda.index = (1:m)[bc$y == max(bc$y)][1]\n\tif (lambda.index == 1 || lambda.index == m)\n\t\twarning(\"optimal lambda found at the edge of search range\")\n\tbc$x[lambda.index]\n}\n\n\nbcTrans = function(z, lambda) {\n\tif (lambda == 1.0)\n\t\tzt = z\n\telse if (abs(lambda) > 0.0)\n\t\tzt <- (z^lambda - 1)/lambda\n\telse zt <- log(z)\n\tzt\n}\n",
    "created" : 1475158307403.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "941670820",
    "id" : "9ADA69B6",
    "lastKnownWriteTime" : 1475158661,
    "last_content_update" : 1475158661649,
    "path" : "E:/Intamap/SVNI/intamap/R/transGaussian.R",
    "project_path" : "R/transGaussian.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}