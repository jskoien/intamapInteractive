{
    "collab_server" : "",
    "contents" : "\\name{intamap-package}\n\\alias{intamap-package}\n\n\\title{A package providing methods for automatic interpolation:\npre-processing, parameter estimation, spatial prediction and post processing }\n\n\\description{\nThis package provides functionality for automatic interpolation of spatial data. \nThe package was originally developed as the computational back-end of the intamap web service, but \nis now a stand-alone package as maintenance of the web service has ended. \n}\n\n\\section{ General setup }{\n\nThe normal work flow for working with the \\code{intamap} package can best be illustrated\nwith the following R-script. The procedure starts with reading data and meta data,\nthen setting up an object which is used in the following functions: preprocess data,\nestimate parameters, compute spatial predictions, and post process them\n(i.e., write them out):\n\n\\preformatted{\nlibrary(intamap)\n\n# set up intamap object, either manually:\nobj = list(\n        observations = readOGR(\"PG:dbname=postgis\", \"eurdep.data\"),\n        predictionLocations = readOGR(\"PG:dbname=postgis\", \"eurdep1km.grid\"),\n        targetCRS = \"+init=epsg:3035\",\n        params = getIntamapParams()\n)\nclass(obj) = c(\"idw\")\n\n# or using createIntamapObject\nobj = createIntamapObject(\n        observations = readOGR(\"PG:dbname=postgis\", \"eurdep.data\"),\n        predictionLocations = readOGR(\"PG:dbname=postgis\", \"eurdep1km.grid\"),\n        targetCRS = \"+init=epsg:3035\",class = c(\"idw\")\n)\n\n\n\n\n# run test:\ncheckSetup(obj)\n\n# do interpolation steps:\nobj = preProcess(obj)\nobj = estimateParameters(obj) # faster\nobj = spatialPredict(obj)\nobj = postProcess(obj)\n}\n\nOur idea is that a script following this setup will allow the full\nstatistical analysis required for the R back-end to the automatic\ninterpolation service, and provides the means to extend the current\n(over-simplistic) code with the full-grown statistical analysis routines\ndeveloped by INTAMAP partners. Running the package independently under\nR gives the user more flexibility in the utilization than what is possible \nthrough the web-interface.\n\nLet us look into detail what the code parts do:\n\\preformatted{\nlibrary(intamap)\n}\nThe command \\code{library(intamap)} loads the R code of the \\code{intamap}\npackage to the current R session, along with the packages required for\nthis (sp, gstat, akima, automap, mvtnorm, evd, MASS). It is also recommended\nto install and load rgdal on those platforms where this package is available.\nAll packages need to be available to the\nR session, which is possible after downloading them from \nthe Comprehensive R Network Archives (CRAN) (\\url{https://cran.r-project.org})\n\n\\preformatted{\n# set up intamap object:\nobj = createIntamapObject(\n        observations = readOGR(\"PG:dbname=postgis\", \"eurdep.data\"),\n        predictionLocations = readOGR(\"PG:dbname=postgis\", \"inspire1km.grid\"),\n        targetCRS = \"+init=epsg:3051\", \n        class = \"idw\"\n)\n}\n\nThis code sets up a list object called \\code{obj}, and assigns a class\n(or a group of classes) to it. This list should hold anything we need in the next steps, and the\nbare minimum seems to be measured point data (which will be extended to \npolygon data) and prediction locations,\nand a suggestion what to do with it. Here, the data are read from a\nPostGIS data base running on localhost; data base connections over a\nnetwork are equally simple to set up. From the data base \\code{postgis}\nthe tables \\code{eurdep.data} and \\code{inspire1km.grid} are read; it\nis assumed that these have their SRID (spatial reference identifier) set.\n\nThe suggestion what to do with these data is put in the classes,\n\\code{idw}. This will determine which \\emph{versions} of \\code{preProcess},\n\\code{parameterEstimate} etc will be used: \\code{intamap} provides \\emph{methods}\nfor each of the \\emph{generic} functions \n\\code{preProcess}, \n\\code{estimateParameters},\n\\code{spatialPredict}, \n\\code{postProcess}.\nAlthough it would be possible to apply two classes in this case (\\code{dataType} in addition to \\code{idw}), \nas the choice of pre- and post-processing steps \ntend to be data-dependent, we have tried to limit the number of classes to one for most applications.\n\nThe S3 method mechanism (used here) hence requires these versions to\nbe called \\code{preProcess.idw}, \\code{estimateParameters.idw},\n\\code{spatialPredict.idw}, and \\code{postProcess.idw} (and eventually \nalso \\code{preProcess.eurdep} and \\code{preProcess.eurdep}).\n\nTo see that, we get in an interactive session:\n\\preformatted{\n> library(intamap)\nLoading required package: sp\nLoading required package: gstat\nLoading required package: rgdal\nGeospatial Data Abstraction Library extensions to R successfully loaded\n> methods(estimateParameters)\n[1] estimateParameters.automap*         estimateParameters.copula*         \n[3] estimateParameters.default*         estimateParameters.idw*            \n[5] estimateParameters.linearVariogram* estimateParameters.transGaussian*  \n[7] estimateParameters.yamamoto*           \n}\n\nNow if a partner provides additional methods for BayesianKriging, one could integrate them by\n\\preformatted{\nclass(obj) = \"BayesianKriging\"\n}\n\nand provide some or all of the functions\n\\code{preProcess.BayesianKriging},\n\\code{estimateParameters.BayesianKriging},\n\\code{spatialPredict.BayesianKriging}, and\n\\code{postProcess.BayesianKriging}, which would be called automatically\nwhen using their generic form (\\code{preProcess} etc).  \n\nIt is also possible to provide a method that calls another\nmethod. Further, for each generic there is a default method. For\n\\code{estimateParameter} and \\code{spatialPredict} these print an\nerror message and stop, for the pre- and postprocessing the default\nmethods may be the only thing needed for the full procedure; if no\n\\code{preProcess.BayesianKriging} is found, \\code{preProcess.default}\nwill be used when the generic (\\code{preProcess}) is called.\n\nIf a method does something, then it adds its result to the object it\nreceived, and returns this object. If it doesn't do anything, then it\njust passes (returns) the object it received.\n\nTo make these different methods exchangable, it is needed that they can\nall make the same assumptions about the contents of the object that they\nreceive when called, and that what they return complies with what the\nconsequent procedures expect. The details about that are given in the\ndescriptions of the respective methods, below.\n\nBecause a specific interpolation method implemented may have its peculiar\ncharacteristics, it may have to extend these prescriptions by passing\nmore information than described below, for example information about\npriors from \\code{estimateParameters} to \\code{spatialPredict}.\n\nThe choice between methods is usually done based on the type of problem\n(extreme values present, computation time available etc.). The possibility\nfor parallel processing of the prediction step is enabled for some of the main methods.\nTo be able to take advantage of multiple CPUs on a computer, the package\n\\code{doParallel} must be installed, additionally the parameter nclus must be set to\na value larger than 1.\n\n}\n\n\\section{Input object components}{\n\\describe{\n\\item{\\code{observations}}{ object of class \\\n                code{\\link[sp:SpatialPoints]{SpatialPointsDataFrame}}, containing\n                a field \\code{value} that is the target variable.}\n\\item{\\code{predictionLocations}}{ object extending class \\code{\\link[sp:Spatial-class]{Spatial}}, containing\nprediction locations.}\n\\item{\\code{targetCRS}}{ character; target CRS or missing}\n\\item{\\code{formulaString}}{formula string for parameter estimation and prediction functions}  \n\\item{\\code{params}}{\\code{list} of parameters, to be set in \\code{\\link{getIntamapParams}}. These parameters include: }\n\n\\describe{\n\\item{doAnisotropy = FALSE}{Defining whether anisotropy should be calculated}\n\\item{removeBias = NA}{Defining whether biases should be removed, and in case yes, which ones\n                   (\\code{localBias} and \\code{regionalBias} implemented}\n\\item{addBias = NA}{Defining which biases to be added in the \\code{\\link{postProcess}} function.\n                    This has not yet been implemented.}\n\\item{biasRemovalMethod = \\code{\"LM\"}}{character; specifies which methods to use to remove bias. See below.}\n\\item{doSegmentation = FALSE}{Defining if the predictions should be subject to segmentation.\n                 Segmentation has been implemented, but not the use of it.}\n\\item{nmax = 50}{for local kriging: the number of nearest observations that\n            should be used for a kriging prediction or simulation, where\n            nearest is defined in terms of the space of the spatial locations.\n            By default, 50 observations are used. }\n\\item{ngrid = 100}{The number of grid points to be used if an Averaged Cumulative\n             Distribution Function (ACDF) needs to be computed for unbiased kriging}\n\\item{nsim=100}{Number of simulations when needed}\n\\item{block = numeric(0)}{Block size; a vector with 1, 2 or 3 values containing the size\n                  of a rectangular in x-, y- and z-dimension respectively\n                  (0 if not set), or a data frame with 1, 2 or 3 columns,\n                  containing the points that discretize the block in the\n                  x-, y- and z-dimension to define irregular blocks relative to\n                  (0,0) or (0,0,0) - see also the details section of \\code{\\link[gstat]{predict.gstat}}.\n                  By default, predictions or simulations refer to the support of the data values. }\n\\item{processType = \\code{\"gaussian\"} }{If known - the distribution of the data. Defaults to gaussian,\n                   analytical solutions also exists in some cases for logNormal.\n                   This setting only affects a limited number of methods, e.g. the\n                   block prediciton}\n\\item{confProj = FALSE}{If set, the program will attempt conform projections in \\code{\\link{preProcess}},\n                calling the function \\code{\\link{conformProjections}}.}\n\\item{nclus = 1}{The number of clusters to use, if applying to a method which can \n   run processes in parallel. Currently implemented for methods \\code{automap},\n   \\code{copula} and \\code{psgp}.}\n\\item{debug.level = 0}{Used in some functions for giving additional output. See \n                individual functions for more information. }\n\\item{...}{Additional parameters that do not exist in the default parameter set,\n           particularly parameters necessary for new methods within the \\code{intamap}\n           package}\n}\n}\n}\n\\references{ \n\nPebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopulos, D., Pilz, J., Stohlker, U., Morin, G., Skoien, J.O. INTAMAP: The design and implementation f an interoperable automated interpolation Web Service. Computers and Geosciences 37 (3), 2011. \n\n}\n\\keyword{spatial}\n",
    "created" : 1470208819459.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3095830181",
    "id" : "A34575D2",
    "lastKnownWriteTime" : 1473437323,
    "last_content_update" : 1473437323215,
    "path" : "E:/Intamap/SVNI/intamap/man/intamap-package.Rd",
    "project_path" : "man/intamap-package.Rd",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_doc"
}