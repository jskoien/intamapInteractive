{
    "collab_server" : "",
    "contents" : "\n\nunbiasedKrige = function(object, formulaString, observations, predictionLocations, model,\n     outputWhat, nmax, nsim, maxdist, yamamoto, iwqmaxit = 500, iwqCpAddLim = 0.0001, debug.level,...) {\n  dots = list(...)\n  if (is(object,\"Spatial\")) {\n    predictions = object\n    iwqs = outputWhat[names(outputWhat) == \"IWQSEL\"]\n    if (missing(debug.level)) debug.level = 1\n    if (length(iwqs) > 0) {\n      if (missing(formulaString)) {\n        formulaString = as.formula(paste(names(observations)[1],\"~1\"))\n        print(paste(\"warning: formulaString not given, using \",formulaString))\n      }\n      if (missing(nsim) || nsim == 0) nsim = 100\n      if (missing(nmax)) nmax = 10 \n      if (missing(maxdist)) maxdist = Inf\n    }\n    if (missing(predictionLocations)) predictionLocations = predictions\n  } else {\n    outputWhat = object$outputWhat\n    iwqs = outputWhat[names(outputWhat) == \"IWQSEL\"]\n    predictions = object$predictions\n    params = object$params\n    if (missing(debug.level)) debug.level = object$debug.level\n    if (length(iwqs) > 0) {\n      model = object$variogramModel\n      formulaString = object$formulaString\n      observations = object$observations\n      if (missing(nsim)) nsim = object$params$nsim\n      if (missing(nmax)) nmax = object$params$nmax\n      if (missing(maxdist)) maxdist = object$params$maxdist\n      if (nsim == 0) nsim = 100\n      if (missing(predictionLocations)) predictionLocations = object$predictionLocations\n    }\n  }\n  if (is.null(maxdist)) maxdist = Inf\n# Creating the accumulative distribution function\n  acdf = acdfDef(predictions,...)\n#  \n# IWQSEL method requested\n  if (length(iwqs) > 0) {\n    if (\"var1.pred\" %in% names(predictions)) {\n#    Simulations necessary\n      if (inherits(object,\"yamamoto\") | (\"yamamoto\" %in% names(dots) && dots$yamamoto)) { \n        zPred = yamamotoKrige (formulaString,observations,predictionLocations,\n          nsim=nsim, nmax = nmax, maxdist = maxdist, model = model,...) \n      } else {\n        zPred = krige(formulaString,observations,predictionLocations,\n                 nsim=nsim, maxdist = maxdist, model = model, nmax=nmax, ...)\n        print(\"Finished simulations\")\n      }\n    } else {\n      zPred = predictions\n    } \n    for (iwq in 1:length(iwqs)) {\n      iwqThresh = iwqs[[iwq]]\n      pThresh = acdfFind(acdf,iwqThresh,inv=TRUE)\n      iname = paste(\"IWQSEL\",iwqThresh,sep=\"\")\n      iwqselRes = iwqsel(zPred@data,acdf,iwqThresh,pThresh,maxit = iwqmaxit, \n          cpAddLim = iwqCpAddLim, debug.level = debug.level, ...)\n      predictions[[iname]] = iwqselRes$zEst \n    }\n  }\n  \n  moks = outputWhat[names(outputWhat) == \"MOK\"]\n  if (length(moks) > 0) {\n#  Modified ordinary kriging prediction\n    for (imok in 1:length(moks)) {\n      mokThresh = moks[[imok]]\n      pThresh = acdfFind(acdf,mokThresh,inv=TRUE)\n      zp = quantile(predictions$var1.pred,pThresh)\n       mname = paste(\"MOK\",mokThresh,sep=\"\")\n      predictions[[mname]] = predictions$var1.pred + mokThresh-zp\n    }\n  }\n      \n  if (is(object,\"Spatial\")) predictions else {\n    if (\"predPoint\" %in% names(object)) {\n      object$predPoint = predictions\n    } else {\n      object$predictions = predictions\n    } \n    return(object)\n  }\n}\n\n\nacdfFindArr = function(FB,zArr,zMin,zInc) {\n  ord = order(zArr)\n  acdfArr = array(c(1:length(zArr)))\n  nFB = dim(FB)[1]\n  for (iz in 1:length(zArr)) {\n    zm = zArr[ord[iz]]\n    id =  as.integer(((zm-zMin)/zInc)+2)\n    if (id >nFB) id = nFB\n    if (id <1) id = 1\n    acdfArr[ord[iz]] = FB[id]\n  }     \n  return(acdfArr) \n}\n\n\n\nacdfFindSimp = function(FB,zVal,zMin,zInc) {\n  if (missing(zMin) | missing(zInc)) {\n    return(acdfFind(FB,zVal))\n  } else {\n#    iv =as.integer((zVal-zMin)/zInc)+2\n#    tval = FB[iv,1]\n#    p = FB[iv,2]\n#    cat(paste(iv,zVal,tval,p,\"\\n\"))\n    id = as.integer(((zVal-zMin)/zInc)+2)\n    if (id > dim(FB)[1]) return(1)\n    if (id < 1) return(0)\n    return(FB[id,2])\n  }\n}\n# FBfindSimp(FBk,2.5,zMin = zmin,zInc = zinc)\n\n\nacdfFind = function(FB,zVal,inv=TRUE,simp=FALSE,...) {\n# Consider using findInterval\n  if (simp & !inv) {\n    if (missing(zMin) | missing(zInc)) {\n      zMin = FB[[1,1]]\n      zInc = FB[[2,1]]-zMin\n    }\n    id = as.integer(((zVal-zMin)/zInc)+2)\n    if (id > dim(FB)[1]) return(1)\n    if (id < 1) return(0)\n    return(FB[id,2])\n  } else {\n    icol = ifelse(inv,1,2)\n    jcol = ifelse(inv,2,1)\n    il = max(which(FB[,icol] <= zVal))\n    ih = min(which(FB[,icol] > zVal))\n    b = FB[[ih,icol]]-FB[[il,icol]]\n    b1 = (zVal-FB[[il,icol]])/b\n    b2 = (FB[[ih,icol]]-zVal)/b\n    if (il < 1) {\n      il = 1\n      b1 = 0\n      b2 = 1\n    }\n    if (ih > dim(FB)[1]) {\n      ih = dim(FB)[1]\n      b1 = 1\n      b2 = 0\n    }\n  }\n#  cat(paste(\"FBfind\",icol,jcol,zVal,il,ih,b,b1,b2,\"\\n\"))\n  return(b1*FB[ih,jcol] + b2*FB[il,jcol])\n}\n\n\n\nacdfDef = function(pPred,nfb = 200,...) {\n# Creating the ACDF from ordinary kriging predictions\n  FB = as.matrix(data.frame(ia = c(1:nfb),0))\n  if (\"var1.pred\" %in% names(pPred)) {\n  # kriging prediction\n    nPred = dim(pPred@data)[1]\n    zmin = min(pPred$var1.pred)-3*sqrt(max(pPred$var1.var))\n    zmax = max(pPred$var1.pred)+3*sqrt(max(pPred$var1.var))\n    zinc = (zmax-zmin)/(nfb-2)\n    z0 = zmin-0.5*zinc\n    for (ia in 1:nfb) {\n      zVal = z0+zinc*(ia-1)\n      FB[ia,1] = zVal\n      FB[ia,2] = sum(pnorm((zVal-pPred$var1.pred)/sqrt(pPred$var1.var+0.00001)))/nPred\n#    cat(paste(ia,round(zinc,3),round(zVal,3),round(FB[ia,1],3),round(FB[ia,2],6),\"\\n\"))\n    }\n  } else if (\"sim1\" %in% names(pPred)) {\n  # simulations\n    zmin = min(pPred)\n    zmax = max(pPred)\n    zinc = (zmax-zmin)/(nfb-2)\n    z0 = zmin-0.5*zinc\n    pall = dim(pPred)[1] * dim(pPred)[2]\n    for (ia in 1:nfb) {\n      zVal = z0+zinc*(ia-1)\n      FB[ia,1] = zVal\n      FB[ia,2] = sum(pPred<zVal)/pall\n    }\n  }\n  return(FB)\n}\n\n\n\n\n",
    "created" : 1475158446145.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4068607009",
    "id" : "4B443273",
    "lastKnownWriteTime" : 1475158660,
    "last_content_update" : 1475158660472,
    "path" : "E:/Intamap/SVNI/intamap/R/unbiasedPoint.R",
    "project_path" : "R/unbiasedPoint.R",
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}