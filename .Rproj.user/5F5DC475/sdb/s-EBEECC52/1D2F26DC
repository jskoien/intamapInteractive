{
    "collab_server" : "",
    "contents" : "  \nblockPredict = function(object,...) {\n  object = spatialPredict.block(object,...)\n  return(object)\n} \n \n\nspatialPredict.block = function(object,...) {\n#spablock = function(object,...) {\n# Define which methods can actually handle block kriging directly\n  blockMethods = c(\"automap\",\"idw\")\n# Extract some of the parameters and variables from the object\n# - for easier access\n  params = getIntamapParams(object$params, ...)\n  blockWhat = object$blockWhat\n  dots = list(...)\n  block = params$block\n  nmax = params$nmax\n  maxdist = params$maxdist\n  if (is.null(maxdist)) maxdist = Inf\n  observations = object$observations\n  formul = object$formulaString\n  predictionLocations = object$predictionLocations\n  outputWhat = object$outputWhat\n  if (!inherits(predictionLocations,\"SpatialPolygons\") &\n      !inherits(predictionLocations,\"SpatialLines\") &\n      !inherits(predictionLocations,\"SpatialPixels\") &\n      !inherits(predictionLocations,\"SpatialGrid\") &\n      !length(block) >0 ) {\n      warning(\"prediction locations are not grid, blocks, polygons or lines\")\n      warning(\"calling point prediction\")\n      return(spatialPredict(object,...))\n  }\n  \n  if (!(\"variogramModel\" %in% names(object)) &\n      !inherits(object,\"idw\") & !inherits(object,\"copula\")) object = estimateParameters(object, ...)\n  if (params$processType %in% c(\"gaussian\",\"logNormal\") &\n      sum(class(object) %in% blockMethods) >= 1) {\n# Check if we might be able to use an analytical solution - \n# Possible if we want a prediction for Gaussian or logNormal distribution, only 1 cluster\n# Only possible for certain methods - now hard coded into blockMethods\n    if (inherits(object,\"idw\")) return(spatialPredict(object,...))\n    form = object$formulastring\n    depVar = as.character(form[2])\n# We have to discuss whether it makes sense to have the test of logNormal here, \n# as it can easily create some inconsistencies.\n# We have to be sure that the variogram is also found from the logarithmised data\n    if (params$processType == \"logNormal\") observations[[depVar]] = log(observations[[depVar]])\n      predictions = krige(object$formulaString, observations, predictionLocations,\n                          object$variogramModel, block = block, nmax = nmax, maxdist = maxdist)\n    if (params$processType == \"logNormal\") {\n      predictions$var1.pred = exp(predictions$var1.pred + predictions$var1.var/2) \n      warning(\"Note that the back-calculated lognormal predictor is only approximate, as the Lagrange parameter is not included\")\n    }\n    print(\"performed ordinary block kriging\")\n    object$predictions = predictions\n  }\n  \n# Point predictions/simulations are necessary\n    if (\"MOK\" %in% names(object$outputWhat) | \"IWQSEL\" %in% names(object$outputWhat)\n      | inherits(object,\"yamamoto\") | length(names(blockWhat)) > 0\n      | !inherits(object,blockMethods)) {\n# Create a new object for point simulation\n    pointObject = object\n#   Create a grid\n    if (!inherits(predictionLocations, \"SpatialPolygons\")) {\n      if (length(block) > 0) {\n        lbox = vector(\"list\", length(predictionLocations))      \n        coords = coordinates(predictionLocations)\n        for (ii in 1:length(predictionLocations)) {\n          xy = coords[ii,]\n          xmin = xy[1]-block[1]/2\n          xmax = xy[1]+block[1]/2\n          ymin = xy[2]-block[ifelse(length(block) == 2, 2, 1)]/2\n          ymax = xy[2]+block[ifelse(length(block) == 2, 2, 1)]/2\n          Sr1 = Polygon(cbind(c(xmin,xmax,xmax,xmin,xmin),c(ymin,ymin,ymax,ymax,ymin)))\n          lbox[[ii]] = Polygons(list(Sr1), paste(\"i\",ii,sep = \"\"))\n        }\n        SpP = SpatialPolygons(lbox, 1:length(predictionLocations), \n              proj4string = CRS(proj4string(predictionLocations)))      \n      } else if (inherits(predictionLocations, \"SpatialPixels\") | \n                 inherits(predictionLocations, \"SpatialPixels\")) {\n        SpP = as(predictionLocations, \"SpatialPolygons\")      \n      } else stop(\"predictionLocations are not SpatialPolygons or gridded and block size not given, block prediction not possible \")\n    } else SpP = predictionLocations\n\n    pointObject$predictionLocations = findGrid(predictionLocations = SpP,\n          params = params)\n\n# Do we need point predictions or simulations?\n# Prediction only if only need mean\n    \n    nsim = ifelse(all(names(outputWhat)==\"mean\") & blockWhat == \"none\",0, params$nsim) \n    vmod = object$variogramModel\n    nmax = ifelse(params$nmax == Inf & dim(coordinates(pointObject$predictionLocations))[1] > 200,20,params$nmax)\n    pointObject = spatialPredict(pointObject,nsim=params$nsim,nmax = nmax, ...)\n    pointObject$predictions = pointObject$predictions[,grep(\"sim\",names(pointObject$predictions))]\n    object$pointPredictions = pointObject$predictions\n    object$pointLocations = pointObject$predictionLocations\n    object = spatialAggregate(object, SpP)\n    if (object$params$debug.level < 2) object$pointPredictions = \n                  \"pointPredictions deleted from object, debug.level < 2\"\n  }\n  return(object)\n\n}\n\n\n  \nspatialAggregate = function(object, SpP) {\n  predictionLocations = object$predictionLocations\n  pointLocations = object$pointLocations  \n  if (\"predictions\" %in% names(object)) {\n    predictions = object$predictions\n  } else {\n    predictions = predictionLocations\n  }\n    \n  pointPredictions = object$pointPredictions\n  coor = SpatialPoints(pointPredictions)\n  sims = pointPredictions[,grep(\"sim\",names(pointPredictions))>0]\n  \n  params = object$params\n  thresh = params$thresh\n  outputWhat = object$outputWhat\n  blockWhat = object$blockWhat\n  if (\"mean\" %in% names(outputWhat)) {\n     if (blockWhat == \"none\") blockWhat = list(mean = TRUE) else blockWhat$mean = TRUE\n  }\n  predAggr = aggregate(sims,by=SpP,mean)\n  if (\"data\" %in% names(getSlots(class(predictions)))) {\n    predictions@data = data.frame(predictions@data,predAggr@data)\n  } else predictions = SpatialDataFrame(predictions,predAggr@data)\n  if (length(blockWhat) > 0 && blockWhat != \"none\") {\n    for (ib in 1:length(blockWhat)) {\n      what = blockWhat[ib]\n      if (names(what) == \"fat\") {\n        thresh = what[[1]]\n        fatf = function(arr,thresh) sum(I(arr>thresh))/length(arr)  \n        fatx = aggregate(sims,SpP,FUN = fatf,thresh=thresh)@data\n        vmean = rowMeans(fatx[,-1])\n        vvar = apply(fatx[,-1],MARGIN=1,FUN=function(arr) var(arr))\n        vname = paste(\"fat\",what[[1]],sep=\"\")\n        vnamevar = paste(\"fatVar\",what[[1]],sep=\"\")\n      } else if (names(what) == \"blockMax\" && what[[1]]) {\n        bmax = aggregate(sims,by=SpP,FUN = max)@data\n        vmean = rowMeans(bmax[,-1])\n        vvar = apply(bmax[,-1],MARGIN=1,FUN=function(arr) var(arr))\n        vname = \"blockMax\"\n        vnamevar = \"blockMaxVar\"\n      } else if (names(what) == \"blockMin\" && what[[1]]) {\n        bmin = aggregate(sims,by=SpP,FUN = min)@data\n        vmean = rowMeans(bmin[,-1])\n        vvar = apply(bmin[,-1],MARGIN=1,FUN=function(arr) var(arr))\n        vname = \"blockMin\"\n        vnamevar = \"blockMinVar\"\n      } else if (names(what) == \"mean\" && what[[1]]) {\n        bmean = aggregate(sims, by = SpP, FUN = mean)@data\n        vmean = rowMeans(bmean[,-1])\n        vvar = apply(bmean[,-1],MARGIN=1,FUN=function(arr) var(arr))\n        vname = \"blockMean\"\n        vnamevar = \"blockMeanVar\"\n      }\n      predictions@data[vname] = vmean        \n      predictions@data[vnamevar] = vvar             \n    }\n  }\n  object$predictions = predictions\n  object\n}  \n\n  \n                  \nfindGrid = function(predictionLocations, params) {\n#  newdata needs to be SpatialPointsDataFrame.\n#  3 options:\n#  1) If sampleSubregions is false then sample the whole region of newdata\n#  2) If sampleSubregions is false subregions denominated the string \"regCode\" \n#     are sampled\n#  3) If block is given, \n#  If both n and cellsize is given, cellsize is used, unless the sampling\n#  will be done in subregions, where cellsize does not make sense\n#  If cellmin gives empty polygons, sMin gives a minimum number of samples from\n#  each polygon   \nsMin = params$sMin\nncell = params$ngrid\ncellsize = params$cellsize\nsampleSubregions = params$subSamp\n\n  if (!is.null(sampleSubregions) && sampleSubregions) {\n    if (!missing(cellsize)) ncell = bbArea(bbox(predictionLocations))/(cellsize*cellsize)\n    if (ncell < sMin) ncell = sMin\n    ids = sapply(slot(predictionLocations, \"polygons\"), function(i) slot(i, \"ID\"))\n    for (i in 1:length(predictionLocations@polygons)) {\n      ldata = predictionLocations@polygons[i][[1]]\n      nl = length(ldata@Polygons)\n      cArea = 0\n    # Summing up areas of all subpolygons in a polygon\n      for (ip in 1:nl) cArea = cArea + ldata@Polygons[[ip]]@area\n      aR = spsample(ldata,type=\"regular\", n=ncell)\n      naR = length(coordinates(aR)[,1])      \n      if (is(predictionLocations,\"SpatialPolygonsDataFrame\")) {\n        idl = ids[i]\n        idNew = as.character(rep(idl,naR))\n      } else idNew = as.character(rep(i,naR))\n      predGridNew = SpatialPointsDataFrame(aR,data=data.frame(id = idNew))\n# \n      if (i == 1) {\n        id = idNew\n        predGrid = predGridNew\n      } else {\n        id = c(id,idNew)\n        predGridNew = SpatialPointsDataFrame(aR,data=data.frame(id = idNew))                     \n        predGrid = rbind(predGrid,predGridNew)\n      }\n    }\n  } else {  \n    if (!is.null(cellsize)) {\n      predLoc = spsample(predictionLocations,type=\"regular\",cellsize=cellsize) \n    } else {\n      predGrid = spsample(predictionLocations,ncell*length(predictionLocations),type=\"regular\")\n    }\n  }\n\nif (!is.na(proj4string(predictionLocations))) proj4string(predGrid) = proj4string(predictionLocations) \npredGrid\n}\n\n",
    "created" : 1475157902740.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1981913285",
    "id" : "1D2F26DC",
    "lastKnownWriteTime" : 1475158240,
    "last_content_update" : 1475158240775,
    "path" : "E:/Intamap/SVNI/intamap/R/aggregation.R",
    "project_path" : "R/aggregation.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}