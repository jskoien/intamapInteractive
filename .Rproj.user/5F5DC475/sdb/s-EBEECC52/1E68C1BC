{
    "collab_server" : "",
    "contents" : "#####################################\n#\n# getIntamapParams - function for setting intamap parameters\n# Input - parameters to be set\n# Output - parameter list containing:\n#\n# formulaString = formula string for parameter estimation and \n#                 prediction functions\n# doAnisotropy = defining whether anisitropy should be calculated\n# removeBias = definition which biases to remove\n# addBias = Biases that can be added again (if possible, e.g. regional biases \n#           might be added, localBias cannot be added\n# biasRemovalMethod = Which method to use for bias removal, \n#                    \"UK\" (universal kriging using whole dataset) \n#                     or \"LM\" (local methods)\n# doCluster = if the prediction region should be divided into a group of clusters\n# maxCluster = The maximum number of clusters if clusters will be used\n# numberOfClusters = If a fixed number of clusters is to be used (still \n#                    to be decided exactly how to use this\n# nmax = maximum number of neighbours to use for kriging\n# predictType = List of different prediction types (all TRUE/FALSE)\n#     threshCor = Prediction corrected for shrinkage in kriging predictions\n#                 MOK Modified ordinary kriging predictor\n#                 IWQSEL IWQSEL-predictor\n#     block = Predictions for block \n#     blockFat = Estimated fraction above threshold (if block kriging)\n# thresh = Threshold for Fraction above threshold (blockFat) and exceedance probability (exc)\n# isEmergency = parameter to disable certain functions, e.g. bias correction\n# confProj = if Projections should be conformed, setting intCRS as \n#            interpolation projection\n# processType = gaussian, nonGaussian, logNormal\n########################################\n\n\ngetIntamapParams = function(oldPar, newPar,...){\n  dots = list(...)\n  twoLists = FALSE\n  if (!missing(oldPar) && !inherits(oldPar,\"IntamapParams\")) {\n    if (!missing(newPar)) {\n      newPar2 = newPar \n      newPar = oldPar \n      twoLists = TRUE\n    }  else newPar = oldPar\n    oldPar = getIntamapDefaultParams()\n  } else if (missing(oldPar)) {\n    oldPar = getIntamapDefaultParams()\n  }\n  if (!missing(newPar)) oldPar = modifyList(oldPar,newPar)\n  if (twoLists) oldPar = modifyList(oldPar,newPar2)\n  if (length(dots) >0) oldPar = modifyList(oldPar,dots)\n  class(oldPar) = \"IntamapParams\"\n  return(oldPar)\n}\n\n\ngetIntamapDefaultParams = function(doAnisotropy = TRUE, \n  testMean = FALSE, removeBias = NA,  addBias = NA, biasRemovalMethod = \"LM\", \n  nmax = 50, maxdist = Inf, ngrid = 100, nsim = 100, sMin = 4, block=numeric(0),  \n  processType=\"gaussian\",\n  confProj = FALSE, debug.level = 0, nclus = 1, ... ) {\nreturn(list(doAnisotropy = doAnisotropy, testMean = testMean, removeBias = removeBias, addBias = addBias,\n  biasRemovalMethod = biasRemovalMethod, \n  nmax = nmax, maxdist = maxdist, ngrid = ngrid, nsim = nsim, sMin = 4, block = block, processType = processType,\n  confProj = confProj, debug.level = debug.level, nclus = nclus, ... ))\n}\n\n\n\n\ncreateIntamapObject = function(observations, obsChar, formulaString, predictionLocations=100,\n  targetCRS,boundaries,boundaryLines,intCRS, params=list(),boundFile,lineFile,class=\"idw\",\n  outputWhat, blockWhat = \"none\",...) {\n  object = list()\n  dots = list(...)\n  if (\"targetCRS\" %in% names(params) && missing(targetCRS)) {\n    targetCRS = params$targetCRS\n    params = params[-which(names(params) == \"targetCRS\")]\n    if (requireNamespace(\"rgdal\")) targetCRS = CRSargs(CRS(targetCRS))\n  }\n  if (\"intCRS\" %in% names(params) && missing(intCRS)) {\n    intCRS = params$intCRS\n    params = params[-which(names(params) == \"intCRS\")]\n    if (requireNamespace(\"rgdal\")) intCRS = CRSargs(CRS(intCRS))\n  }\n  if (!is.na(proj4string(observations)) && requireNamespace(\"rgdal\")) \n      observations@proj4string = CRS(proj4string(observations))\n  if (!missing(predictionLocations) && !is.na(proj4string(predictionLocations)) && requireNamespace(\"rgdal\")) \n      predictionLocations@proj4string = CRS(proj4string(predictionLocations))\n  if (!missing(observations) && !extends(class(observations),\"Spatial\")) \n  \tstop(\"observations not object of class Spatial*\")\n  if (missing(observations)) \n  \tstop(\"Observations not submitted, cannot perform interpolation without data\")\n  if (!missing(observations)) \n  \tobject$observations = observations \n  if (!missing(obsChar) && !all(is.na(obsChar)))\n    object$obsChar = obsChar\n  \n  if (missing(formulaString) || is.null(formulaString)) {\n    if (\"value\" %in% names(observations)) {\n      formulaString = \"value~1\"\n    } else formulaString = paste(names(observations)[1],\"~1\")\n    print(paste(\"createIntamapObject: formulaString is missing, using: \",formulaString))\n  }\n  if (!inherits(formulaString,\"formula\")) \n  \tformulaString = as.formula(formulaString)\n  object$formulaString = formulaString\n  if (!is.numeric(predictionLocations)) {\n    if (extends(class(predictionLocations),\"Spatial\")) {\n      object$predictionLocations = predictionLocations\n    } else stop(\"predictionLocations not spatial object or number of samples\")    \n  } else {\n    if (!missing(boundaries)) {\n      warning(\"createIntamapObject: No prediction locations submitted - sampling from boundaries\")\n      object$predictionLocations = spsample(boundaries,predictionLocations,\"regular\", offset = c(0.5,0.5)) \n    } else if (!missing(observations)) {\n      warning(\"createIntamapObject: No prediction locations submitted - sampling from bbox of observations\")\n      object$predictionLocations = spsample(observations,predictionLocations,\"regular\", offset = c(0.5,0.5)) \n    }\n  }\n  if (!missing(boundaries)) {\n    object$boundaries = boundaries\n    if (!is.na(proj4string(boundaries))) object$boundCRS = proj4string(boundaries)\n  }\n  if (!missing(targetCRS) && \n    !(is.na(proj4string(observations)) && is.na(proj4string(predictionLocations)))) object$targetCRS = targetCRS\n  if (!missing(intCRS) && \n    !(is.na(proj4string(observations)) && is.na(proj4string(predictionLocations)))) object$intCRS = intCRS\n  if (!missing(observations) && \"regCode\" %in% names(observations)) \n              object$regCode = unique(observations$regCode)\n\n  if (missing(params)) object$params = getIntamapParams() else \n    object$params = getIntamapParams(params) \n  if (!missing(boundaries)) {\n    objectboundaries = boundaries\n  } else if (!missing(boundFile) && requireNamespace(\"rgdal\")) {\n  \t# EJP:\n    #if (require(maptools)) object$boundaries = readShapePoly(boundFile) else\n    #  warning(\"maptools not installed, not able to read boundaries\")\n\t  object$boundaries = readOGR(\".\", boundFile)\n  }\n  if (!missing(boundaryLines)) {\n    object$boundaryLines = boundaryLines\n  } else if (!missing(lineFile)) {\n    object$lineFile = lineFile\n    load(lineFile)\n    object[[boundaryLines]] = lineFile\n  }\n  if (length(names(dots))>0)\n  \tobject = modifyList(object,dots)\n  if (missing(outputWhat)) {\n    if (class == \"idw\") {\n      outputWhat = list(mean = TRUE)\n    } else outputWhat = list(mean = TRUE, variance = TRUE)\n  }\n  object$outputWhat = outputWhat\n  object$blockWhat = blockWhat\n  if (object$params$confProj) object = conformProjections(object)\n\n  class(object) = class\n  \n  if (sum(names(params) %in% c(\"methodParameters\", \"variogramModel\", \"copulaParams\")) > 1) \n    stop(\"you can only give one out of methodParameters, variogramModel and copulaParams\")\n  \n  if (\"methodParameters\" %in% names(params)) {\n    methodParameters = params$methodParameters\n    if (length(grep(\"assign\",methodParameters)) >0) stop(\"Illegal attempt to call function assign through methodParameters\")\n    if (length(grep(\"call\",methodParameters)) >0) stop(\"Illegal attempt to call function call through methodParameters\")\n    if (length(grep(\"cat\",methodParameters)) >0) stop(\"Illegal attempt to call function cat through methodParameters\")\n    if (length(grep(\"count\",methodParameters)) >0) stop(\"Illegal attempt to call function count* through methodParameters\")\n    if (length(grep(\"download\",methodParameters)) >0) stop(\"Illegal attempt to call function download through methodParameters\")\n    if (length(grep(\"env\",methodParameters)) >0) stop(\"methodParameters contain illegal string env\")\n    if (length(grep(\"eval\",methodParameters)) >0) stop(\"Illegal attempt to call function eval through methodParameters\")\n    if (length(grep(\"file\",methodParameters)) >0) stop(\"Illegal attempt to call function file* through methodParameters\")\n    if (length(grep(\"format\",methodParameters)) >0) stop(\"Illegal attempt to call function format* through methodParameters\")\n    if (length(grep(\"gettext\",methodParameters)) >0) stop(\"Illegal attempt to call function gettext through methodParameters\")\n    if (length(grep(\"options\",methodParameters)) >0) stop(\"Illegal attempt to call function options through methodParameters\")\n    if (length(grep(\"parse\",methodParameters)) >0) stop(\"Illegal attempt to call function parse through methodParameters\")\n    if (length(grep(\"paste\",methodParameters)) >0) stop(\"Illegal attempt to call function paste through methodParameters\")\n    if (length(grep(\"print\",methodParameters)) >0) stop(\"Illegal attempt to call function print through methodParameters\")\n    if (length(grep(\" q\",methodParameters)) >0) stop(\"methodParameters contain illegal string q\")\n    if (length(grep(\"read\",methodParameters)) >0) stop(\"Illegal attempt to call function read* through methodParameters\")\n    if (length(grep(\" rm\",methodParameters)) >0) stop(\"Illegal attempt to call function rm through methodParameters\")\n    if (length(grep(\"scan\",methodParameters)) >0) stop(\"Illegal attempt to call function scan through methodParameters\")\n    if (length(grep(\"sink\",methodParameters)) >0) stop(\"Illegal attempt to call function sink through methodParameters\")\n    if (length(grep(\"shell\",methodParameters)) >0) stop(\"Illegal attempt to call function shell through methodParameters\")                                                                           \n    if (length(grep(\"sprintf\",methodParameters)) >0) stop(\"Illegal attempt to call function sprintf through methodParameters\")\n    if (length(grep(\"system\",methodParameters)) >0) stop(\"Illegal attempt to call function system through methodParameters\")\n    if (length(grep(\"url\",methodParameters)) >0) stop(\"methodParameters contain illegal string url\")\n    if (length(grep(\"write\",methodParameters)) >0) stop(\"Illegal attempt to call function write through methodParameters\")\n   \n    params = params[-which(names(params) == \"methodParameters\")]\n    eval(parse(text = methodParameters))\n  }\n  if (\"variogramModel\" %in% names(params)) {\n    object$variogramModel = params$variogramModel\n    if (class == \"idw\" | class == \"automatic\") class(object) = \"automap\"\n  }\n  if (\"copulaParams\" %in% names(params)) {\n    object$copulaParams = params$copulaParams\n    class(object) = \"copula\"\n  }\n  if (!is.null(object$params$set.seed)) set.seed(object$params$set.seed)\n  return(object)\n}\n\n\n\n\n#########################################################\n# ConformProjection\n#\n# Input: Intamap object\n#\n# Output: Intamap object with projections of observations and\n#         predictionLocations equal to\n#         (a) targetCRS - if not longlat\n#         (b) observationCRS - if not longlat\n#         (c) predictionCRS - if not longlat\n#         (d) intCRS = \"+init=epsg:3035\" if both above are longlat\n#\n############################################################\n\nconformProjections = function(object) {\n  projObs = is.projected(object$observations)\n  projPred = is.projected(object$predictionLocations)\n  if (is.na(projObs) & !is.na(projPred)) {\n    proj4string(object$observations) = proj4string(object$predictionLocations)\n    warning(\"proj4string was not set for observations, assumed to be equal to proj4string for predictionLocations\")\n  } else if (!is.na(projObs) & is.na(projPred)) {\n    proj4string(object$predictionLocations) = proj4string(object$observations)\n    warning(\"proj4string was not set for predictionLocations, assumed to be equal to proj4string for observations\")\n  } else if (all(is.na(projObs),is.na(projPred))) {\n    return(object) \n  } else if (!all(!is.na(projObs),!is.na(projPred))) {\n# This should never occur with the modifications above\n    stop(paste(\"observations or predictionLocations is neither projected or LongLat, whereas the other one is. \\n\",  \n       \"Observation projection is:\",projObs,\"\\n\", \n       \"Prediction projection is:\",projPred,\"\\n\" ))\n  }\n  observations = object$observations\n  predictionLocations = object$predictionLocations\n  obsCRS = proj4string(observations)\n  predCRS = proj4string(predictionLocations)\n  if (requireNamespace(\"rgdal\")) {\n    if (\"intCRS\"%in% names(object)) {\n      intCRS = object$intCRS\n    } else if (CRSargs(CRS(obsCRS)) == CRSargs(CRS(predCRS)) && !length(grep(\"longlat\",obsCRS)) >0) {\n      intCRS = CRSargs(CRS(obsCRS))\n    } else {\n      if (\"targetCRS\" %in% names(object) && !length(grep(\"longlat\", CRSargs(CRS(object$targetCRS)))) > 0) {\n        targetCRS = object$targetCRS\n        intCRS = targetCRS\n      } else {\n        targetCRS = predCRS\n        if (!length(grep(\"longlat\",obsCRS)) > 0) {\n          intCRS = obsCRS\n        } else {\n          if (!length(grep(\"longlat\",predCRS)) >0) {\n            intCRS = predCRS\n          } else {                \n  #          intCRS = \"+init=epsg:3035\"\n            stop(\"Interpolation in longlat not possible, a projection is needed.\")          \n          } \n        }\n      }\n    }\n    if (CRSargs(CRS(obsCRS)) != CRSargs(CRS(intCRS))) \n       object$observations = spTransform(observations,CRS(intCRS))\n    if (CRSargs(CRS(predCRS)) != CRSargs(CRS(intCRS))) \n      object$predictionLocations = spTransform(predictionLocations,CRS(intCRS))\n    if (!is.null(object$boundaries)) {\n    \tboundaries = object$boundaries\n      boundCRS = proj4string(object$boundaries)\n    \tif (CRSargs(CRS(boundCRS)) != CRSargs(CRS(intCRS))) \n      \tobject$boundaries = spTransform(boundaries,CRS(intCRS))\n    }\n    if (!intCRS %in% names(object)) object$intCRS = intCRS\n  } else {\n    warning(\"intamap: rgdal not installed, not able to transform coordinates, if necessary\")\n  }\n\treturn(object)\n}\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1475157526220.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4033623704",
    "id" : "1E68C1BC",
    "lastKnownWriteTime" : 1475157896,
    "last_content_update" : 1475157896520,
    "path" : "E:/Intamap/SVNI/intamap/R/init.R",
    "project_path" : "R/init.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}